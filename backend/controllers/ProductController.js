import ProductModel from '../models/Product.js';
import UserModel from '../models/User.js';

export const addComment = async (req, res) => {
  try {
    const { text, rating } = req.body;
    const productId = req.params.id;
    const userId = req.userId; // –ü–æ–ª—É—á–µ–Ω –∏–∑ —Ç–æ–∫–µ–Ω–∞
    const user = await UserModel.findById(userId);
    const product = await ProductModel.findById(productId);
    if (!product) {
      return res.status(404).json({ message: '–ü—Ä–æ–¥—É–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω' });
    }
    // if (rating == 0) {
    //   return res.status(404).json({ message: '–†–µ–π—Ç–∏–Ω–≥ —Ö—É–π–Ω—è' });
    // }
    const updatedProduct = await ProductModel.findByIdAndUpdate(
      { _id: productId },
      {
        $push: {
          comments: {
            user: userId,
            fullName: user.fullName, // –ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –º–æ–¥–µ–ª–∏ User
            avatarUrl: user.avatarUrl, // URL –∞–≤–∞—Ç–∞—Ä–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            text: text,
            rating: rating,
            date: new Date(),
          },
        },
      },
      { runValidators: true }
    );

    if (updatedProduct.nModified === 0) {
      return res.status(400).json({ message: '–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω' });
    }

    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–π –ø—Ä–æ–¥—É–∫—Ç —Å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è–º–∏
    const updatedProductWithComments = await ProductModel.findById(productId);
    res.status(200).json(updatedProductWithComments);

  } catch (err) {
    console.error(err);
    res.status(500).json({ message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è', error: err.message });
  }
};

// likeComment

export const likeComment = async (req, res) => {
  try {
    const { id, action, idComment } = req.params; // –ü–æ–ª—É—á–∞–µ–º ID —Ç–æ–≤–∞—Ä–∞ –∏ –¥–µ–π—Å—Ç–≤–∏–µ (–ø–ª—é—Å –∏–ª–∏ –º–∏–Ω—É—Å)
    const userId = req.userId; // –ü–æ–ª—É—á–µ–Ω –∏–∑ —Ç–æ–∫–µ–Ω–∞
    // const user = await UserModel.findById(userId);

    if (!['likeUp', 'likeDown'].includes(action)) {
      return res.status(400).json({ message: '–ù–µ–≤–µ—Ä–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ' });
    }

    const product = await ProductModel.findById(id);

    if (!product) {
      return res.status(404).json({ message: '–ü—Ä–æ–¥—É–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω' });
    }

    const comment = product.comments.find( (c) => c._id.toString() === idComment );

    if (!comment) {
      return res.status(404).json({ message: '–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω' });
    }

    if (action === 'likeUp') {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ –ª–∞–π–∫ –æ—Ç —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      const existingLike = comment.likesUp.find(like => like.user.toString() === userId);
      


      const existingLikeDown = comment.likesDown.find(like => like.user.toString() === userId);
      if (existingLikeDown) {
        // –ï—Å–ª–∏ –ª–∞–π–∫ —É–∂–µ –µ—Å—Ç—å, —É–¥–∞–ª—è–µ–º –µ–≥–æ
        comment.likesDown = comment.likesDown.filter(like => like.user.toString() !== userId);
      }



      if (existingLike) {
        // –ï—Å–ª–∏ –ª–∞–π–∫ —É–∂–µ –µ—Å—Ç—å, —É–¥–∞–ª—è–µ–º –µ–≥–æ
        comment.likesUp = comment.likesUp.filter(like => like.user.toString() !== userId);
      } else {
        // –ï—Å–ª–∏ –ª–∞–π–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω, –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π –ª–∞–π–∫
        comment.likesUp.push({ user: userId, like: true });
      }
    } 
    // –õ–æ–≥–∏–∫–∞ –¥–ª—è likesDown
    else if (action === 'likeDown') {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É–∂–µ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π –ª–∞–π–∫ –æ—Ç —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      const existingLike = comment.likesDown.find(like => like.user.toString() === userId);


      const existingLikeUp = comment.likesUp.find(like => like.user.toString() === userId);
      if (existingLikeUp) {
        // –ï—Å–ª–∏ –ª–∞–π–∫ —É–∂–µ –µ—Å—Ç—å, —É–¥–∞–ª—è–µ–º –µ–≥–æ
        comment.likesUp = comment.likesUp.filter(like => like.user.toString() !== userId);
      }



      if (existingLike) {
        // –ï—Å–ª–∏ –ª–∞–π–∫ —É–∂–µ –µ—Å—Ç—å, —É–¥–∞–ª—è–µ–º –µ–≥–æ
        comment.likesDown = comment.likesDown.filter(like => like.user.toString() !== userId);
      } else {
        // –ï—Å–ª–∏ –ª–∞–π–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω, –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π –ª–∞–π–∫
        comment.likesDown.push({ user: userId, like: true });
      }
    } else {

      return res.status(400).json({ message: '–ù–µ–≤–µ—Ä–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ' });
      
    }

    await product.save(); // —Å–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–¥—É–∫—Ç —Å –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–º

    res.json(product); // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –ø—Ä–æ–¥—É–∫—Ç

  } catch (err) {
    console.error(err);
    res.status(500).json({
      message: "–û—à–∏–±–∫–∞ like",
      error: err.message,
    });
  }
};


export const editComment = async (req, res) => {
  try {
    const { productId, reviewId } = req.params;
    const { text, rating } = req.body;

    const product = await ProductModel.findById(productId);
    if (!product) {
      return res.status(404).json({ message: "Product not found" });
    }

    const comment = product.comments.id(reviewId);
    if (!comment) {
      return res.status(404).json({ message: "Comment not found" });
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –∏ —Ä–µ–π—Ç–∏–Ω–≥ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è
    comment.text = text;
    comment.rating = rating;

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è
    await product.save();

    // return res.status(200).json({ message: "Comment updated successfully", product });
    return res.status(200).json({ message: "Comment updated successfully", updatedComment: comment });

  } catch (error) {
    console.error(error);
    return res.status(500).json({ message: "Server error" });
  }
}

export const removeComment = async (req, res) => {
  try {
    const productId = req.params.id;
    const reviewId = req.params.idComment;

    const product = await ProductModel.findById(productId);
    if (!product) {
      return res.status(404).json({ message: '–ü—Ä–æ–¥—É–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω' });
    }

    await ProductModel.updateOne(
      { _id: productId },
      { $pull: { comments: { _id: reviewId } } }
    );

    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ–ª—å–∫–æ id —É–¥–∞–ª—ë–Ω–Ω–æ–≥–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è
    res.json({
      message: '–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω',
      deletedCommentId: reviewId, // üëà –í–æ—Ç —ç—Ç–æ —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥—É –∏ –Ω—É–∂–Ω–æ
    });
  } catch (err) {
    console.log(err);
    res.status(500).json({
      message: '–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π',
    });
  }
};



export const getPagination = async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 3;
  const skip = (page - 1) * limit;

  try {
    const [products, total] = await Promise.all([
      ProductModel.find().skip(skip).limit(limit),
      ProductModel.countDocuments()
    ]);

    res.json({
      page,
      limit,
      totalPages: Math.ceil(total / limit),
      totalItems: total,
      products,
    });
  } catch (err) {
    res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  }
};




export const getAll = async (req, res) => {
  try {
    const products = await ProductModel.find().exec(); // –¥–ª—è —Ä–∞–∑–≤—ë—Ä—Ç—ã–≤–∞–Ω–∏—è usera –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
    res.json(products);
  }

  catch(err) {
    console.log(err);
    res.status(500).json({
      message: "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç—ã",
    });
  }
}


export const getOne = async (req, res) => {
  try {
    const productId = req.params.id; // –ü–æ–ª—É—á–∞–µ–º ID –∏–∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤

    // –û–±–Ω–æ–≤–ª—è–µ–º viewsCount –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç
    // –µ—Å–ª–∏ –ø—Ä–æ—Å—Ç–æ –ø–æ–ª—É—á–∏—Ç—å —Ç–æ findBId –≤—Ä–æ–¥–µ
    const doc = await ProductModel.findOneAndUpdate(
      { _id: productId },
      { $inc: { viewsCount: 1 } },
      { returnDocument: 'after' } // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç
    )
    if (!doc) {
      return res.status(404).json({
        message: '–ü—Ä–æ–¥—É–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω',
      });
    }

    res.json(doc);

  } catch (err) {
    console.log(err);
    res.status(500).json({
      message: '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–æ–¥—É–∫—Ç',
    });
  }
};

// export const sortProducts = async (req, res) => {

//   try {
//     const { sort, filter, category, branding, country } = req.query;
//     // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ—Ä—è–¥–æ–∫ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏
//     const sortOrder = sort === "asc" ? 1 : sort === "desc" ? -1 : null;
//     // –§–æ—Ä–º–∏—Ä—É–µ–º —Ñ–∏–ª—å—Ç—Ä
//     let filterCondition = {};
//     // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
//     if (category) {
//       const categoryName = category.trim().replace(/\s+/g, ''); // –£–±–∏—Ä–∞–µ–º –ø—Ä–æ–±–µ–ª—ã
//       if (categoryName === 'allbranding') {
//         filterCondition.category = { $exists: true }; // –í—Å–µ —Ç–æ–≤–∞—Ä—ã
//       } else {
//         filterCondition.category = categoryName; // –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
//       }
//     }

//     // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä –ø–æ –ø–æ–ª—é sale
//     if (filter === "sale") {
//       filterCondition.sale = { $ne: "0" }; // –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ç–æ–≤–∞—Ä—ã, –≥–¥–µ sale –ù–ï "0%"
//     } else if (filter === "new") {
//       filterCondition.newproduct = true; // –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –Ω–æ–≤–∏–Ω–∫–∞–º
//     }

//     // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä branding (–æ–¥–∏–Ω –±—Ä–µ–Ω–¥)
//     if (branding) {
//       const brandingValue = branding.trim().replace(/\s+/g, ''); // –£–±–∏—Ä–∞–µ–º –ø—Ä–æ–±–µ–ª—ã –∏–∑ branding
//       if (brandingValue === "allbranding") {
//         filterCondition.brand = { $exists: true }; // –í—Å–µ –±—Ä–µ–Ω–¥—ã
//       } else {
//         filterCondition.brand = brandingValue; // –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –æ–¥–Ω–æ–º—É –±—Ä–µ–Ω–¥—É
//       }
//     }

//     if (country) {
//       const countryName = country.trim().replace(/—Å/g, "c");
//       if (countryName.toLowerCase() === "allcountry") {
//         filterCondition.country = { $exists: true };
//       } else {
//         filterCondition.country = { $regex: new RegExp(`^${countryName}$`, "i") }; // –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞
//       }
//     }

//     const query = ProductModel.find(filterCondition);
//     if (sortOrder) query.sort({ price: sortOrder });

//     const products = await query;
//     res.json(products);
//   } catch (error) {
//     res.status(500).json({ error: "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞" });
//   }

  
// };

export const sortProducts = async (req, res) => {
  try {
    const { sort, filter, category, branding, country, page = 1, limit, price } = req.query;

    const sortOrder = sort === "asc" ? 1 : sort === "desc" ? -1 : null;

    let filterCondition = {};

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if (category) {
      const categoryName = category.trim().replace(/\s+/g, '');
      filterCondition.category = categoryName === 'allbranding'
        ? { $exists: true }
        : categoryName;
    }

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ñ–∏–ª—å—Ç—Ä –ø–æ —Å–∫–∏–¥–∫–µ –∏–ª–∏ –Ω–æ–≤–∏–∑–Ω–µ
    if (filter === "sale") {
      filterCondition.sale = { $ne: "0" };
    } else if (filter === "new") {
      filterCondition.newproduct = true;
    }

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –±—Ä–µ–Ω–¥
    if (branding) {
      const brandingValue = branding.trim().replace(/\s+/g, '');
      filterCondition.brand = brandingValue === "allbranding"
        ? { $exists: true }
        : brandingValue;
    }

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å—Ç—Ä–∞–Ω—É
    if (country) {
      const countryName = country.trim().replace(/—Å/g, "c");
      filterCondition.country = countryName.toLowerCase() === "allcountry"
        ? { $exists: true }
        : { $regex: new RegExp(`^${countryName}$`, "i") };
    }

    const pageNumber = parseInt(page);
    const limitNumber = parseInt(limit);
    const skip = (pageNumber - 1) * limitNumber;
    const preisRange = parseFloat(price) || 0;




    // const total = await ProductModel.countDocuments(filterCondition);

    // const products = await ProductModel.find(filterCondition)
    //   .sort(sortOrder ? { price: sortOrder } : {})
    //   .skip(skip)
    //   .limit(limitNumber);

    // res.json({
    //   page: pageNumber,
    //   limit: limitNumber,
    //   totalPages: Math.ceil(total / limitNumber),
    //   totalItems: total,
    //   products,
    // });

    const allProducts = await ProductModel.find(filterCondition);

    // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Ü–µ–Ω–µ (—É—á–∏—Ç—ã–≤–∞—è —Å–∫–∏–¥–∫—É)
    const filtered = allProducts.filter(product => {
      const basePrice = parseFloat(product.price);
      const sale = parseFloat(product.sale?.replace('%', '') || '0');
      const finalPrice = basePrice - (basePrice * sale / 100);
      return finalPrice >= preisRange;
    });

    const total = filtered.length;
    const sorted = sortOrder
      ? filtered.sort((a, b) => {
          const aPrice = parseFloat(a.price) - (parseFloat(a.price) * parseFloat(a.sale?.replace('%', '') || '0') / 100);
          const bPrice = parseFloat(b.price) - (parseFloat(b.price) * parseFloat(b.sale?.replace('%', '') || '0') / 100);
          return sortOrder === 1 ? aPrice - bPrice : bPrice - aPrice;
        })
      : filtered;

    const paginated = sorted.slice(skip, skip + limitNumber);

    res.json({
      page: pageNumber,
      limit: limitNumber,
      totalPages: Math.ceil(total / limitNumber),
      totalItems: total,
      products: paginated,
    });


    
  } catch (error) {
    res.status(500).json({ error: "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞" });
  }
};




export const topProducts = async (req, res) => {
  try {
    const topProducts = await ProductModel.find()
      .sort({ viewsCount: -1 }) // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ø–æ–ª—é viewsCount –≤ –ø–æ—Ä—è–¥–∫–µ —É–±—ã–≤–∞–Ω–∏—è
      .limit(6); // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç 5 –ø—Ä–æ–¥—É–∫—Ç–∞–º–∏

    res.json(topProducts);
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞:', error.message);
    res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞', error: error.message });
  }
}